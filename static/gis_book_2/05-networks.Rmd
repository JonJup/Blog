# Graph Analysis

In this script, we will work with network data in R.
To this end will, we will use different packages: `igraph`, `tidygraph`, and `network` for representing networks in R through specific object classes.
`OCN` for the creation of optimal channel networks, and `sfnetworks` for spatial networks.

## The igraph package

We will start with the `igraph`package [@Csardi2006].
It is a very popular implementation of networks in R, which is also available for Python and C++.

```{r, results='hide'}
library(dplyr)
library(purrr)
library(magrittr)
library(igraph)
```

First, we create a simple graph with three nodes (`n`).
Thee first node is connected to the second node, the second to the third, and the third to the first.
This specified in the `edges` argument, which takes a vector.
Each pair of entries in the vector gives the number or name of the originating and the terminating node.
For the network I described above this works out to `c(1,2,2,3,3,1)`.

```{r}
g <- graph(edges = c(1,2,2,3,3,1), n = 3)
plot(g)
```

The base plot function returns an image where nodes are represented by orange circles with their names inscribed.
The edges are arrows, so we know that the default option of the `graph()` function is to create directed graphs.
We can create a non-directed network by setting `directed=FALSE`.

```{r}
g <- graph(edges = c(1,2,2,3,3,1), n = 3, directed = FALSE)
plot(g)
```

If we have more nodes in the network than are indicated in the edge list, the additional nodes are unconnected.

```{r}
g <- graph(edges = c(1,2,2,3,3,1), n = 6, directed = FALSE)
plot(g)
```

We can also create complete, undirected graphs that form predefined geometries like tetrahedrons.
See the help file of `make_graph` for more geometries.

```{r}
g <- make_graph("Tetrahedron")
plot(g)
```

A further alternative is to use a *literal* description of the graph, where named nodes are connected via `-`.

```{r}
g <- graph_from_literal(Fred-Daphne, Velma-Shaggy, Shaggy-Fred)
plot(g)
```

We can see that `-` is an undirected edge.
You can use as many `-` as you like, which might improve legibility in some cases.

```{r}
g <- graph_from_literal(Fred--Daphne, Velma----Shaggy, Shaggy----Fred)
plot(g)
```

The `:` colon operator links vertex sets, so that all vertices from both sets are connected.

```{r}
g <- graph_from_literal(Fred-Daphne:Velma-Shaggy, Fred-Shaggy-Scooby)
plot(g)
```

In directed graphs, you can indicate the direction with `-+` where the + marks the head of the arrow.

```{r}
g <- graph_from_literal(Fred-+Daphne:Velma+-Shaggy, Fred+-Shaggy+-+Scooby)
plot(g)
```

Now lets have a look at how the graph is represented non-graphically to us:

```{r}
g
```

The output always starts with IGRAPH, telling us the we have an igraph object.
Next, is a seven character string.
For me, while I write this, it is `c98a3fb`.
For you it will be different.
It will even be different when you read this, because the number changes every time I compile this document.
This character string is the ID of the graph.
After the ID follow four letters:      
1. D or U for directed or undirected\
2.
N or - for named or unnamed vertices\
3.
W or - for weighted or unweighted edges\
4.
B or - for bipartite and unipartite networks.

After the four letter code, we get the number of nodes (5) and the number of edges (7, the edge between Shaggy and Scooby is counted double).
If the whole graph has a name that is printed after the the numbers.
All of these properties can also be queried independently.

```{r}
# number of nodes
vcount(g)
# number of edges
ecount(g)
# is the graph directed?
is.directed(g)
# is the graph bipartite
is.bipartite(g)
# is the graph weighted
is.weighted(g)
# is the graph named
is.named(g)
```

Below that the attributes are given under `+attr :`.
For our graph, we get one attribute: `name(v/c)`.
The code after the attribute name (in our case the name is `name`), tells us whether the attribute is of a node (v), edge (e), or whole graph (g) and whether the attribute is a character (c), numeric (n), logical (l), or other (x).
So our attribute `names` concerns nodes and is a character.
Lastly, the edges are listed.

We can change the attributes of nodes by accessing the nodes of the graph with `V()`.
Then we can change and add attributes in the following way:

```{r}
# name the nodes Bill, Joe, Josy, Laura, and Tyler
V(g)$name <- c("Bill", "Joe", "Josy", "Laura", "Tyler")
```

We can see the change in the summary and the plot.

```{r}
g
plot(g)
```

We can also add a new attribute called `math grade`.

```{r}
V(g)$math_grade <- c(4,2,3,1,1)
g
```

```{r}
cols <- c("blue","red","black","magenta")
plot(g, vertex.color = cols[V(g)$math_grade])
```

We can access the edges in the same way.

```{r}
E(g)
E(g)$likes <- sample(1:4, ecount(g), replace = TRUE)
plot(g, edge.color = cols[E(g)$likes])
```

## From data to graph

In many instances you start out with an adjacency matrix or an edge list which we might want to turn into a graph.
To illustrate how this works, I will simulate an example for each of those data types.
First, we create an adjacency matrix.
Remember, an adjacency matrix is a matrix filled with zeros and ones.
A one in the j$^{th}$ column of the i$^{th}$ row implies that the j$^{th}$ node is connected to the i$^{th}$ node, while a zero would imply that they are not connected.
Here, we simulate a 20x20 matrix that is randomly populated with zeros and ones.
For this, we use random draws from the binomial distribution `rbinom()` .
The binomial distribution is what you might use to simulate a coin toss or any other event that can lead to two different outcomes in each trial.
In this case, we draw 400 numbers (`20^2`), each draw only consist of one trail and a likelihood of success (i.e. a 1) of 0.1.

```{r}
adjacency <- matrix(rbinom(20^2, 1, .1), ncol = 20)
# turn all values on the diagonal to zero as a node is not connected to itself. 
diag(adjacency) <- 0
ga <- graph_from_adjacency_matrix(adjacency, mode = "undirected")
plot(ga)
```

We can also go the other way around and turn a graph into a adjacency matrix.

```{r}
as_adjacency_matrix(ga)
```

You see that the format is unusual for matrices in R.
As it says above the output, this is a sparse matrix.
Most entries are zero and therefore zeros are not explicitly represented in the matrix to save computer memory.

Next, we will create an edge list and derive a graph from it.
`letters` is a vector that contains the alphabet we and take a sample of 20 letters with `sample()`.
The `replace = TRUE` argument enables us to sample the same letter multiple time.
After we have two vectors with randomly drawn letters (`letters1` and `letters2`) we use them as columns in a matrix with the `cbind()` function.

This matrix is the edge list with which we can create a graph using the `graph_from_edgelist()` function.

```{r}
letters1 <- sample(letters, 20, replace = TRUE)
letters2 <- sample(letters, 20, replace = TRUE)
el <- cbind(letters1, letters2)
el
ge <- graph_from_edgelist(el, directed = FALSE)
plot(ge)

```

Until now all networks we have created have been unipartite.
There has been one set of nodes and in principle each node could be connected to every other node.
In bipartite networks, there are two distinct sets of nodes.
Each node is only connected to nodes from the other set.
Below, I create an example of an bipartite network.
We have six students (S1-S6) that can register in four courses (C1-C4).
The *affiliation matrix* has one column per class and one row per student.
If a student is part of a class than the respective cell is a one.
If a student does not visit a class then it is a zero.
Both classes and students are nodes but no student is directly connected to another student and classes are not connected among themselves either.
When we print the graph to the console, we can see that the graph is bipartite by looking at the four letter code: `UN-B`

```{r}
C1 <- c(1,1,1,0,0,0) 
C2 <- c(0,1,1,1,0,0) 
C3 <- c(0,0,1,1,1,0) 
C4 <- c(0,0,0,0,1,1) 
aff.df <- data.frame(C1,C2,C3,C4) 
row.names(aff.df) <- c("S1","S2","S3","S4","S5","S6")
bn <- graph.incidence(aff.df)
bn
```

```{r}
plt.x <- c(rep(2, 6), rep(4, 4))
plt.y <- c(7:2, 6:3)
lay <- as.matrix(cbind(plt.x, plt.y))
shapes <- c("circle", "square")
colors <- c("blue", "red")
plot(
        bn,
        vertex.color = colors[V(bn)$type + 1],
        vertex.shape = shapes[V(bn)$type + 1],
        vertex.size = 10,
        vertex.label.degree = -pi / 2,
        vertex.label.dist = 1.2,
        vertex.label.cex = 0.9,
        layout = lay
)

```

## Centrality measures

Next, we will turn to the centrality measures we discussed in the lecture.
The most basic measure is the degree centrality which is just the degree of a node.
We can get the degree with the function `degree()`.

```{r}
degree(ga)
```

We can assign each node its degree as an attribute and plot the network with accordingly colored nodes.
For this we need two new packages: `ggraph` [@Pedersen2022] and tidygraph [@Pedersen2022a].

We will look at both packages a little more in depth later in this tutorial.

```{r, results='hide'}
library(tidygraph)
library(ggraph)
```


```{r}
V(ga)$degree <- degree(ga)
ga
ga2 <- as_tbl_graph(ga)
ggraph(ga2) + 
        geom_edge_link(lwd = 0.4) + 
        geom_node_point(aes(col = degree), size = 3)
```

Other centrality metrics can also be computed with the epynomous functions from the `igraph` package.

```{r}
V(ga)$closeness <- closeness(ga)
V(ga)$betweenness <- betweenness(ga)
```

Another nice way to display these data is through radial plots.
However, for this we again need two additional packages: `sna` [@Butts2022] and `network` [@Butts2008] .
`sna` makes the plots and `network` provides the object class that `sna` uses.

```{r, results='hide'}
library(network)
library(sna)
```

In the following plots, nodes that are closer to the center have higher centrality. 
```{r}
A <- as_adjacency_matrix(ga, sparse=FALSE)
ga3 <- as.network.matrix(A)
gplot.target(
        ga3,
        degree(ga3, gmode = "graph"),
        main = "Degree",
        circ.lab = FALSE,
        circ.col = "skyblue",
        usearrows = FALSE,
        edge.col = "darkgray"
)
gplot.target(
        ga3,
        closeness(ga3, gmode = "graph"),
        main = "Closeness",
        circ.lab = FALSE,
        circ.col = "skyblue",
        usearrows = FALSE,
        edge.col = "darkgray"
)
gplot.target(
        ga3,
        betweenness(ga3, gmode = "graph"),
        main = "Betweenness",
        circ.lab = FALSE,
        circ.col = "skyblue",
        usearrows = FALSE,
        edge.col = "darkgray"
)
```

## Visualization

For non-spatial networks, there is no correct position for any one node.
They can be freely arranged in space.
However, certain arrangements will make it easier to understand the network while others will simply be confusing.
Visualization is as much art as science but there are some common sense rules that usually result in a less confusing figure:

-   Minimize edge crossings

-   Maximize the symmetry of the layout of nodes

-   Minimize the variability of the edge lengths

-   Maximize the angle between edges when they cross or join nodes

-   Minimize the total space used for the network display

    These were taken from @Luke_2015

We will quickly go through some options that `igraph` gives you and then cover the basics of the `ggraph` package.

As a baseline, we start with the default plot from an `igraph` object.

```{r}
plot(ga)
```

We can change the color of nodes with `vertex.color` and the color of edges with `edge.color`.

```{r}
par(mfrow = c(1,2))
plot(ga, vertex.color="cyan")
plot(ga, edge.color="cyan")
```

We can add a title with

```{r}
plot(ga, main="Random layout")
```

Next we can change the layout of the graph, that means the rules, the algorithm, which is used to optimize the position of the nodes.

```{r}
par(mfrow = c(1,3))
plot(ga, layout=layout.circle, main = "circle")
plot(ga, layout=layout.fruchterman.reingold, main = "fruchterman")
plot(ga, layout=layout.random, main = "random")

```

We also have the option to create an interactive 2d and 3d graph with `tkplot()` and `rglplot()`.
It is not possible to embed the result in this html file but you can use the code here to try it out yourself.

```{r, eval = FALSE}
tkplot(ga)
```

```{r, eval = FALSE}
rglplot(ga)
```

With that we come to `ggraph`, which is an effort to place network visualization inside the ggplot frame work.
As we have seen above we need a `tidygraph` object to use `ggraph`.
Here, we can use the same object we used above `ga2`.
Each `ggraph` plot starts with the same function: `ggraph()`.
The only argument in this function is the object we wish to display.
As in `ggplot2` this object is not a working plot yet.

```{r}
ga2 %>% 
        ggraph()
```

All we see is a gray background.
To visualize the data we need to add geoms.
First, we will add the edges.
There are mutiple options here and I will show some of them.

```{r}
ga2 %>% ggraph() + geom_edge_link()
ga2 %>% ggraph() + geom_edge_bend()
ga2 %>% ggraph() + geom_edge_arc()
```

Next, we have a look at the nodes.

```{r}
ga2 %>% ggraph() + geom_node_point()
ga2 %>% ggraph() + geom_node_label(aes(label = degree))
ga2 %>% ggraph() + geom_node_tile(width = 1, height = 1)
```

Of course, we can also show both in one plot.

```{r}
ga2 |> ggraph() + geom_edge_link() + geom_node_point()

ga2 |> ggraph() + 
        geom_edge_arc() + 
        geom_node_tile(
                width = .1,
                height = .1, 
                aes(fill = degree)
                )

```

## Network Models

We can simulate network models with `igraph` .
A poisson random graph is simulated with `erdos.renyi.game()` where `n` is the number of nodes, `m` the number of edges , `p` the probability of two nodes sharing an edge and the type is either `gnm` or `gnp`, depending on whether you supply the number of edges or the probability of adjacency.

```{r}
prg1 <- erdos.renyi.game(n=12,10,type='gnm')
prg2 <- erdos.renyi.game(n=12,0.1,type='gnp')
par(mfrow = c(1,2))
plot(prg1) 
plot(prg2)
```

A small world network is created with `watts.strogatz.game()`, where `dim` is the dimension of the starting lattice, `size` the size of the lattice along each dimension, `nei` the neighborhood of the lattice in which nodes are connected and `p` the rewiring probability.

```{r}
watts.strogatz.game(dim=1,size=100,nei=2,p=0.5) |> 
        as_tbl_graph() |> 
        ggraph() + 
        geom_edge_link() + 
        geom_node_point()
        
```

Preferential attachment models are created with `barabasi.game()`, where `n` is the number of nodes, `m` the number of nodes added in each round and `zero.appeal` a factor that raises the likelihood of binding to a node that has no edges so far above zero.

```{r}
g <- barabasi.game(n = 100, m = 1, directed = FALSE, zero.appeal = .5)
```

```{r}
g <- as_tbl_graph(g)
ggraph(g, layout = "igraph", algorithm = "kk") + 
        geom_edge_link() + 
        geom_node_point()
```

## Optimal Channel Networks

Next we will look at optimal channel networks and their R implementation in the `OCNet` Package [@carraroGenerationApplicationRiver2020].
As always, we first load the package.

```{r}
library(OCNet)
```

Creating a OCN starts with a call to `create_OCN()`.
This function establishes a lattice with `dimX` points in the x direction and dimY points in the y direction.
In this grid it also establishes the flow direction of each point.
The function has many more arguments but usually we do not have to worry about them and can keep the default settings.
Here, we create an OCN in a 20x20 grid.

```{r}
OCN <- create_OCN(dimX = 20, dimY = 20)

```

The function produces a list with `A` a vector of drainage area values (i.e., how many cells does this cell drain)

```{r}
OCN$FD$A

```

and `W` a sparse adjacency matrix.

```{r}
OCN$FD$W
```

The following functions all take the OCN object as argument.
Instead of creating a new object they attach new levels to the list.
`create_OCN()` created the list at the flow direction level (FD).

`landscape_OCN()` creates the DEM of the river network and adds the catchment level (CM) to the list.
The DEM is stored in `OCN$FD$Z`.

```{r}
library(terra)
OCN <- landscape_OCN(OCN)
OCN$FD$Z |> 
        matrix(ncol = 20) |> 
        rast() |> 
        plot()
```

\
<!-- Starts at flow direction level (FD) single nodes. Impose minimum area river network RN, second level. Then aggregated level (AG),nodes correspond to sources, confluences and outlet(s) of the river network identified at the RN level. The whole lattice is then partitioned into areas that directly drain into the nodes at the AG level, or the edges departing from them, thereby constituting the fourth, subcatchment level (SC). -->

Now we need to aggregate the flow network.
This means we set a threshold of how many cells need to flow into one cell for this cell to become a river.
This is done with `aggregate_OCN()`.
This function builds the network at the river network (RN), aggregated (AG), subcatchment (SC) and catchment levels.
We use the default threshold here, so the only argument we need is `OCN`.

```{r}
OCN <- aggregate_OCN(OCN)
```

```{r}
draw_contour_OCN(OCN)
draw_elev2D_OCN(OCN)
draw_elev3D_OCN(OCN)

```

We can also take the OCN and transform it into an `igraph` object. 

```{r}
river_graph <- OCN_to_igraph(OCN, level = "AG")

river_graph |> 
        as_tbl_graph() |>
        ggraph(layout = "igraph", algorithm = "kk") +
        geom_edge_link(color = "blue") +
        geom_node_point(size = 0)

```

## sfnetworks

Lastly, we will turn towards the `sfnetworks` package.
This R package enables us to turn spatial `sf` objects into networks.
Unlike `sfnetworks` uses the `tidygraph` package instead of `igraph`.
However, `tidygraph`is intimately linked to `igraph`.
It takes most of the functions from `igraph` and changes them so they adhere to the *tidy principles*.
There is an implementation of spatial networks in R which works directly with `igraph`, `spNetworks`[@Gelb2021] but we will not cover this package here. 

Since `tidygraph` adheres to the tidy principles, we can use `dplyr` verbs and piping.
So before we work with `sfnetworks`, lets have a short look at `tidygraph`.

To represent networks while following tidy principles (i.e., one row = one observation), `tidygraph` uses two tables for each graph.
One table represents the nodes and the other one the edges.
As an example, we will use the OCN we just created. 

```{r}
river_tidy <- as_tbl_graph(river_graph)
river_tidy
```

`river_tidy` has the class `tbl_graph`. 
We also see the number of nodes and edges and two tibbles: `Node Data` without columns, because the nodes do not have attributes yet and `Edge Data` which is an edge list.

```{r}
plot(river_tidy)
```

Plotting returns the same default output as for an `igraph` object and, in fact, a look at class of `river_tidy` reveals that it has inherited the `igraph` class from `river_graph`.

```{r}
class(river_tidy)
```

If we want to work with either one of the tables we use the `activate()` function.
In the following example, I add an attribute, `letter`, to the nodes.

```{r}
river_tidy %>%
        activate(nodes) %>%
        mutate(letter = sample(x = letters, size = vcount(river_graph), replace = TRUE))
```

We can activate the edges in the same way and we can activate edges and nodes in a single pipe.

```{r}
river_tidy %<>% 
  activate(nodes) %>% 
  mutate(degree = centrality_degree()) %>% 
  activate(edges) %>% 
  mutate(centrality = centrality_edge_betweenness()) %>% 
  arrange(centrality)
```

This will be enough `tidygraph` for now.
The package has almost 300 functions, so we will not be able to cover the package extensively.
Another short introduction by the package's author is available [here](https://tidygraph.data-imaginist.com/).

Now we turn back to `sfnetworks`.

```{r}
library(sf)
library(sfnetworks)
library(mapview)
```

To demonstrate the functionality, we use a demo data set that is included in the Package.
The `roxel` data contain the road network (including bike lanes and footpaths) of the Roxel neighborhod in the German city of MÃ¼nster.

```{r}
data("roxel")
mapview(roxel)
```

There are three options of creating a network from `sf` data with `sfnetwork`.
Either you provide a point data set as nodes and a line data set as edges or you just provide a line data set and the nodes are automatically created at the ends of the lines or you just provide a point data set the the edges are drawn as straight lines between the nodes.

We will try out the *just linestrings* and *just points* versions here.\

We will start with the *just linestrings* option.

```{r}
roxel_nw1 <- as_sfnetwork(roxel, directed = FALSE)
```

The object looks similar to the `tidygraph` object we saw before.
New are the coordinate reference system and the coordinates of the nodes and edges.

```{r}
roxel_nw1
```

```{r}
plot(roxel_nw1)
```

Now we can extract our new nodes as `sf` point object.

```{r}
roxel_point <- st_as_sf(activate(roxel_nw1, nodes), crs = 4326)
roxel_nw2 <- roxel_point |> as_sfnetwork()
plot(roxel_nw2)
```

Working with the spatial network works the same as the non-spatial `tidygraph` networks.

```{r}
roxel_nw1 %>%
  activate("edges") %>%
  mutate(weight = edge_length()) %>%
  activate("nodes") %>%
  mutate(bc = centrality_betweenness(weights = weight, directed = FALSE))
```

We can also use spatial operations like spatial filtering on the network.

```{r}
bbox <- st_bbox(roxel)
bbox |> 
        st_as_sfc() |> 
        st_as_sf(crs=4326) |> 
        st_transform(3035) -> 
        bbox
bbox <- st_buffer(x = bbox, dist = -700, joinStyle  = "MITRE", mitreLimit = 2)
bbox %<>% st_transform(4326)
plot(roxel_nw1, col = "grey")
plot(bbox, border = "red", lty = 4, lwd = 4, add = TRUE)
```

```{r}
filtered = roxel_nw1 %>%
  activate("edges") %>%
  st_filter(bbox) %>%
        activate("nodes") %>%
        st_filter(bbox)
plot(roxel_nw1, col = "grey")
plot(filtered, add = TRUE)
```

We can also filter to observations around a specified point.

```{r}
point = st_centroid(st_combine(roxel_nw1))

filtered = roxel_nw1 %>%
  activate("nodes") %>%
  st_filter(point, .predicate = st_is_within_distance, dist = 500)
plot(roxel_nw1, col = "grey")
plot(filtered, add = TRUE)
plot(point, col = "red", add = TRUE)
```

### Finding paths in the network

Within our network we can find the shortest way to get from point A to point B with the function `st_network_paths()`.
The function uses the most common routing algorithm (i.e., algorithm to find the shortest path): Dijkstras algorithm.
Before we call it, we prepare the data:

1.  We transform it to a projected coordinate system. Now the unit of edge lengths are meters and not fractions of degrees.
2.  Add the edge length as attribute to the edges. In a spatial context the length of edges has a natural interpretation as the spatial distance between points.

```{r}
net <-
        roxel_nw1 %>%
        # transform so that distances are in meters
        st_transform(3035) %>%
        activate("edges") %>%
        mutate(weight = edge_length())

```

We compute the shortest paths from the 38$^{th}$ to the 200$^{th}$ and the 517$^{th}$ node.
The length of the paths is weighted be the `weight` variable which we computed in the code block above.

```{r}
paths = st_network_paths(net, from = 38, to = c(200, 517), weights = "weight")

```

Now what is the output of this function?

```{r}
paths
```

A tibble with two list columns, two rows long.
Each row is one path, i.e., the first row is the path from 38 to 200 and the second row is the path from 38 to 517.
In the first column we get the node ids on the respective path and in the second column we get the edge ids.
To visualize this we will write a small function that plots each node in the node paths (i.e., column 1).

```{r}
plot_path = function(node_path) {
  net %>%
    activate("nodes") %>%
    slice(node_path) %>%
    plot(cex = 1.5, lwd = 1.5, add = TRUE)
}
```

Now we apply this function to all paths and also add symbols to the start and ending points of our paths.

```{r}
colors = sf.colors(3, categorical = TRUE)
plot(net, col = "grey")
paths %>%
  pull(node_paths) %>%
  walk(plot_path)
net %>%
  activate("nodes") %>%
  st_as_sf() %>%
  slice(c(38, 200, 517)) %>%
  plot(col = colors, pch = 8, cex = 2, lwd = 2, add = TRUE)
```

If you need an overview of the distances between all nodes use `st_network_cost()`.

```{r}
cost <- st_network_cost(net)
hist(cost)
```







